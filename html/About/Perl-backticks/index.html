<html lang="en-US"><head>
<title>NovoSial.org: Handling backticks in Perl</title>
<meta name="keywords" content="sial.org, unix, openssl, ssh">
<meta name="msvalidate.01" content="4D4AA5634CCCC8B90DD61AC8A12D742B">
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="generator" content="XML::ApplyXSLT, libxml, and Perl">
<link rel="stylesheet" type="text/css" href="default.css"><meta name="MSSmartTagsPreventParsing" content="TRUE">



<script type="text/javascript" async="" src="ga.js"></script><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28905931-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>

    <div class="header"><h1>Handling backticks in Perl</h1></div>

    <div class="mainBody">
      <div class="subsection"><a href="#s2">Command Line Example</a> | <a href="#s3">Insecure Common Gateway Interface (CGI) Script</a> | <a href="#s4">Solution: <tt class="code">quotemeta</tt></a> | <a href="#s5">Solution: Piped Open</a> | <a href="#s6">Solution: Input Validation</a> | <a href="#s7">Taint Mode</a> | <a href="#s8">Lengthy Shell Commands</a></div><div class="bodymain"><p class="info">In <a href="http://www.perl.org/">Perl</a>, backticks <tt class="code">``</tt> and the <a href="http://perldoc.perl.org/functions/system.html" title="Documentation on the Perl system function"><code class="perl-func">system</code></a> and <a href="http://perldoc.perl.org/functions/exec.html" title="Documentation on the Perl exec function"><code class="perl-func">exec</code></a>
 functions run external programs. Shell escapes should be avoided, as 
they impose needless security, portability, and maintainability 
problems. In many cases, a <a href="http://search.cpan.org/perldoc/perlfunc">Perl function</a>, or module from the <a href="http://www.cpan.org/">Comprehensive Perl Archive Network (CPAN)</a>, can safely replace the backtick, such as using <tt class="code">chmod 0755 @files</tt> in Perl instead of shelling out to <a href="http://www.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1" title="FreeBSD man page search for chmod, section 1"><tt xmlns:xlink="http://www.w3.org/1999/xlink" class="man">chmod(1)</tt></a>.
 However, if the shell escapes are necessary, or time does not permit 
rewriting the offending code, steps must be taken to avoid security 
flaws. Insecure uses of backticks are outlined below, along with 
replacement code that avoids the security problems. For more information
 on backticks, consult the <tt class="code">`STRING`</tt> documentation in <a href="http://perldoc.perl.org/perlop.html" title="Perl programmers reference for perlop"><tt class="perl-pod">perlop</tt></a>.</p><p class="data-shell">$ <kbd>perldoc perlop</kbd></p><p class="info">The examples below use the <a href="http://www.freebsd.org/cgi/man.cgi?query=echo&amp;sektion=1" title="FreeBSD man page search for echo, section 1"><tt xmlns:xlink="http://www.w3.org/1999/xlink" class="man">echo(1)</tt></a> and <a href="http://www.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1" title="FreeBSD man page search for ls, section 1"><tt xmlns:xlink="http://www.w3.org/1999/xlink" class="man">ls(1)</tt></a>
 commands; an attacker would normally use a command that grants elevated
 access to the system or one that carries out illegal actions, such as 
the <a href="http://en.wikipedia.org/wiki/Spam_%28electronic%29">distribution of spam</a> or <a href="http://www.consumer.gov/idtheft/">stealing of customer data</a>. As most programs do not log what commands they run, an audit might never find the breach.</p><p class="info">Consult <a href="http://www.amazon.com/o/ASIN/0596001738" title="ISBN: 0596001738"><span class="book">Perl Best Practices</span></a> and <a href="http://www.amazon.com/o/ASIN/0596003943" title="ISBN: 0596003943"><span class="book">Secure Programming Cookbook for C and C++</span></a> for more information on coding and security best practices. Consider <a href="http://en.wikipedia.org/wiki/Selinux">selinux</a>, <a href="http://en.wikipedia.org/wiki/Systrace">systrace</a>, or other mandatory access controls to either prevent or log the execution of arbitrary commands.</p><h2><a name="s2">Command Line Example</a></h2><p class="info">As written, the following Perl code contains a security flaw.</p><p class="data-shell">$ <kbd>echo a b c</kbd><br>a b c<br>$ <kbd>perl -e 'print `echo @ARGV`' a b c</kbd><br>a b c<br>$ <kbd>perl -e 'print qx/echo @ARGV/' Hello World</kbd><br>Hello World</p><p class="info">Exploits that run an attacker-supplied <tt class="cmd">ls</tt> command:</p><p class="data-shell">$ <kbd>perl -e 'print `echo @ARGV`' a b c <em class="em">'`ls`'</em></kbd><br>a b c <em class="em">CVS index.xml</em><br>$ <kbd>perl -e 'print `echo @ARGV`' a b c <em class="em">'; ls'</em></kbd><br>a b c<br><em class="em">CVS</em><br><em class="em">index.xml</em></p><p class="info">The first exploit runs <tt class="cmd">ls</tt> as a sub command; the second appends the <tt class="cmd">ls</tt> as a second command. In the first example, the single quotes around <tt class="code">`ls`</tt> prevent the <a href="http://novosial.org/shell/index.html">Unix shell</a> from executing the exploit before it is passed to the script.</p><h2><a name="s3">Insecure Common Gateway Interface (CGI) Script</a></h2><p class="info">The <a href="http://novosial.org/perl/backticks/insecure.pl"><tt class="cmd">insecure.pl</tt></a> <acronym title="Common Gateway Interface">CGI</acronym> script can be run from the command line or on a private web server.</p><p class="data">#!/usr/bin/perl -w<br>use strict;<br><br>use CGI;<br>my $cgi = CGI-&gt;new;<br>my $user_input = $cgi-&gt;param('input');<br><br>print $cgi-&gt;header('text/plain');<br>print "Echo returns: ", <em class="em">qx/echo $user_input/</em>;</p><p class="info">To test <tt class="cmd">insecure.pl</tt> locally, run it on the command line.</p><p class="data-shell">$ <kbd>perl insecure.pl input='`ls`'</kbd><br>Content-Type: text/plain; charset=ISO-8859-1<br><br>Echo returns: <em class="em">CVS index.xml insecure.pl</em></p><p class="info">Remote attacks must encode the request. With Perl, <a href="http://search.cpan.org/perldoc/URI::Escape" title="Documentation on the URI::Escape Perl module"><tt class="perl-module">URI::Escape</tt></a> and <a href="http://search.cpan.org/perldoc/LWP" title="Documentation on the LWP Perl module"><tt class="perl-module">LWP</tt></a> can construct and send the exploit code.</p><p class="data-shell">$ <kbd>perl -MURI::Escape -le 'print uri_escape shift' '`ls`'</kbd><br>%60ls%60<br>$ <kbd>lwp-request http://example.org/cgi-bin/insecure.pl?input=%60ls%60</kbd><br>Echo returns: <em class="em">FormMail.pl insecure.pl</em></p><p class="info">Assuming user supplied input must be passed to backtick or <a href="http://perldoc.perl.org/functions/system.html" title="Documentation on the Perl system function"><code class="perl-func">system</code></a>
 calls, there are several ways to prevent improper commands from being 
executed. If possible, do not involve user input with external commands.
 User input could arrive as input to a program, or as an environment 
variable (for example adjusting <tt class="code">PATH</tt>). See <a href="http://perldoc.perl.org/perlsec.html" title="Perl programmers reference for perlsec"><tt class="perl-pod">perlsec</tt></a> for information on sanitizing <tt class="code">%ENV</tt>.</p><h2><a name="s4">Solution: <tt class="code">quotemeta</tt></a></h2><p class="info">Quoting the data may thwart exploits. Use the <a href="http://perldoc.perl.org/functions/quotemeta.html" title="Documentation on the Perl quotemeta function"><code class="perl-func">quotemeta</code></a> function or equivalent <tt class="code">\Q</tt> operator. The first command shows how <tt class="cmd">echo</tt> now prints the exploit code instead of running it, and the second how the data is quoted.</p><p class="data-shell">$ <kbd>perl -e 'print qx/echo \Q@ARGV/' a b c '; ls'</kbd><br>a b c ; ls<br>$ <kbd>perl -le 'print "\Q@ARGV"' a b c '; ls'</kbd><br>a\ b\ c\ \;\ ls</p><p class="info"><a href="http://perldoc.perl.org/functions/quotemeta.html" title="Documentation on the Perl quotemeta function"><code class="perl-func">quotemeta</code></a> and <tt class="code">\Q</tt> share similar function, if slightly different usage.</p><p class="data-shell">$ <kbd>perl -le 'print quotemeta "@ARGV"' a b c '; ls'</kbd><br>a\ b\ c\ \;\ ls</p><p class="info">Multiple
 levels of shell calls may require multiple levels of escaping. This is 
another good reason to avoid shell escapes where possible.</p><h2><a name="s5">Solution: Piped Open</a></h2><p class="info">Avoid running commands though the shell. To avoid the shell, use piped opens and pass commands to <a href="http://perldoc.perl.org/functions/exec.html" title="Documentation on the Perl exec function"><code class="perl-func">exec</code></a> as a list. For more information on piped opens, see <a href="http://perldoc.perl.org/perlipc.html" title="Perl programmers reference for perlipc"><tt class="perl-pod">perlipc</tt></a> and <a href="http://perldoc.perl.org/perlsec.html" title="Perl programmers reference for perlsec"><tt class="perl-pod">perlsec</tt></a>.</p><p class="data">open my $fh_echo, '-|' or <em class="em">exec 'echo', @ARGV</em> or die "echo failed: $!\n";<br>print &lt;$fh_echo&gt;;<br>close $fh_echo;</p><p class="info">If only the exit code of a command is needed, call the <a href="http://perldoc.perl.org/functions/system.html" title="Documentation on the Perl system function"><code class="perl-func">system</code></a> function with a list to avoid invoking the shell, then check <tt class="code">$?</tt> for the return value.</p><p class="data">system 'echo', @ARGV;<br>print "ran okay\n" if 0 == $? &gt;&gt; 8;</p><p class="info">Longer commands can use <tt class="code">qw</tt> to quote a list.</p><p class="data">system qw{/bin/ls -l -i}, @ARGV;<br>print "ran okay\n" if 0 == $? &gt;&gt; 8;</p><p class="info">Note the use of single quotes <tt class="code">'some', 'command'</tt> instead of backticks: <a href="http://perldoc.perl.org/functions/exec.html" title="Documentation on the Perl exec function"><code class="perl-func">exec</code></a> and <a href="http://perldoc.perl.org/functions/system.html" title="Documentation on the Perl system function"><code class="perl-func">system</code></a>
 take lists of strings as an argument. Using backticks would cause Perl 
to execute the code inside the backticks, then pass the output of that 
code to the function call. This executes commands twice, as seen in this
 contrived example:</p><p class="data-shell">$ <kbd>perl -e 'exec `echo echo something`'</kbd><br>something</p><ol class="enum"><li><tt class="cmd">perl</tt> runs the Perl expression specified by the <tt class="cmd-arg">-e</tt> option.<br></li><li>Perl passes <tt class="code">`echo echo something`</tt> to the shell.<br></li><li>The shell <tt class="cmd">echo</tt> command returns <tt class="code">echo something</tt> to Perl.<br></li><li><a href="http://perldoc.perl.org/functions/exec.html" title="Documentation on the Perl exec function"><code class="perl-func">exec</code></a> is then invoked with <tt class="code">echo something</tt>.<br></li><li><a href="http://perldoc.perl.org/functions/exec.html" title="Documentation on the Perl exec function"><code class="perl-func">exec</code></a> replaces the Perl process with <tt class="cmd">echo</tt>, which prints <tt class="code">something</tt>.</li></ol><p class="info">Therefore, only use backticks when running a shell program (though avoid this where possible). When invoking <a href="http://perldoc.perl.org/functions/exec.html" title="Documentation on the Perl exec function"><code class="perl-func">exec</code></a> and <a href="http://perldoc.perl.org/functions/system.html" title="Documentation on the Perl system function"><code class="perl-func">system</code></a>, never use backticks, and instead pass the command to run as a list of strings.</p><h2><a name="s6">Solution: Input Validation</a></h2><p class="info">Input validation ensures the content and length of input data meet specific requirements. For instance, arguments to <tt class="cmd">echo</tt> could be limited to spaces and word characters and be no longer than 32 characters in length.</p><p class="data">my $args = "@ARGV";<br>if (length $args &gt; 32 or $args =~ m/[^\w ]/) {<br>  die "error: invalid command line data\n";<br>}<br>print qx/echo \Q@ARGV/;</p><p class="info">The <tt class="code">[^\w ]</tt> Perl regular expression matches if the <tt class="code">$args</tt> variable contains characters not in <tt class="code">\w</tt> or a space. This is a proper ?deny that which is not explicitly permitted? policy.</p><p class="info">The <a href="http://cpan.org/"><acronym title="Comprehensive Perl Archive Network">CPAN</acronym></a> lists many input checking modules. Search for <kbd class="input">taint</kbd> or <kbd class="input">valid</kbd> in module names. Regular expression libraries such as <a href="http://search.cpan.org/perldoc/Regexp::Common" title="Documentation on the Regexp::Common Perl module"><tt class="perl-module">Regexp::Common</tt></a> also facilitate checks against known data types, such as zip codes or Internet addresses.</p><h2><a name="s7">Taint Mode</a></h2><p class="info">For detailed information on Perl?s taint mode, see <a href="http://perldoc.perl.org/perlsec.html" title="Perl programmers reference for perlsec"><tt class="perl-pod">perlsec</tt></a>. Enabling taint mode forces validation (untainting) of environment variables and user-supplied data. The shell call to <tt class="cmd">echo</tt> fails due to the tainted contents of <tt class="code">@ARGV</tt>:</p><p class="data-shell">$ <kbd>perl -T -e 'print `echo @ARGV`' a b c</kbd><br>Insecure dependency in `` while running with -T switch at -e line 1.</p><p class="info"><em class="em">Taint mode does not solve all problems</em>:
 it must be used in conjunction with other security measures. Even with 
taint mode enabled, sloppy coding will still result in security flaws. A
 blanket untaint with <tt class="code">m/(.*)/</tt> removes the taint, but allows a security flaw through.</p><p class="data-shell">$ <kbd>perl -T -e '"@ARGV" =~ m/(.*)/; $args = $1; \<br>  $ENV{PATH} = "/bin"; print `echo $args`' a b c '; ls'</kbd><br>a b c<br><em class="em">CVS</em><br><em class="em">index.xml</em><br><em class="em">insecure.pl</em></p><h2><a name="s8">Lengthy Shell Commands</a></h2><p class="info">Embedding
 multi-line shell commands in Perl is possible, though I avoid the use 
of shell commands in my scripts?debugging and unit testing one language 
is hard enough, let alone mixing random fragments of another into the 
first. However, if necessary, a here doc allows shell scripts longer 
than a single line to be embedded in a Perl script. Search for <tt class="code">&lt;&lt;EOF</tt> or <tt class="code">here doc</tt> in <a href="http://perldoc.perl.org/perlop.html" title="Perl programmers reference for perlop"><tt class="perl-pod">perlop</tt></a> for more details.</p><p class="data">#!/usr/bin/perl<br>use strict;<br>use warnings;<br><br>my $result = &lt;&lt;`SHELL_IN_PERL_IS_BAD`;<br>echo foo<br>echo bar<br>echo zot<br>SHELL_IN_PERL_IS_BAD<br><br>print $result;</p></div>
    </div>

		<div class="footer"><a href="http://novosial.org/index.html"><img style="border: 0; float: right; margin-top: 1em; margin-right: 1em; margin-bottom: 5em" src="NovosialLogo.gif" alt="NovoSial Icon" width="64" height="64"></a>
<p>This document is released into the public domain. Version 1.3.1</p>
<p>Site provided by <a href="http://steinmetz.org/peter">Peter N. Steinmetz</a></p></div>
  

</body></html>